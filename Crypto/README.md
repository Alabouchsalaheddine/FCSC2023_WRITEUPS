# Crypto - Elliptic Addventure
# Original challenge ðŸ‡«ðŸ‡·
Vous devez retrouver le flag cachÃ© dans les coordonnÃ©es des points donnÃ©s.
# Translated challenge ðŸ‡ºðŸ‡¸
You must find the flag hidden in the coordinates of the given points.
```python
from Crypto.Util.number import bytes_to_long

flag = open("flag.txt", "rb").read().strip()
assert len(flag) == 64

p = 115792089210356248762697446949407573530086143415290314195533631308867097853951
a = -3
b = 41058363725152142129326129780047268409114441015993725554835256314039467401291

K = GF(p)
E = EllipticCurve([K(a), K(b)])

mid = len(flag) // 2
Ax = K(bytes_to_long(flag[:mid]))
Bx = K(bytes_to_long(flag[mid:]))

A = E.lift_x(Ax)
B = E.lift_x(Bx)

print(f"{A + B = }")
print(f"{A - B = }")
```

```
A + B = (65355407912556110148433442581541116153096561277895556722873533689053268966181 : 105815222725531774810979264207056456440531378690488283731984033593201027022521 : 1)
A - B = (103762781993230069010083485164887172361256204634523864861966420595029658052179 : 76878428888684998206116229633819067250185142636730603625369142867437006615111 : 1)
```

# Solution
Given the value of A+B and A-B we can find the coordinates of A and B

Then we can reverse the algorithm to find the flag.

In order to make some computations on the elliptical curve, we can use the mathematics software SageMath available on the following link : https://sagecell.sagemath.org/

```python
# Define the elliptic curve
p = 115792089210356248762697446949407573530086143415290314195533631308867097853951
a = -3
b = 41058363725152142129326129780047268409114441015993725554835256314039467401291
K = GF(p)
E = EllipticCurve([K(a), K(b)])

aPlusB = E.point((65355407912556110148433442581541116153096561277895556722873533689053268966181, 105815222725531774810979264207056456440531378690488283731984033593201027022521, 1))
aMinusB = E.point((103762781993230069010083485164887172361256204634523864861966420595029658052179, 76878428888684998206116229633819067250185142636730603625369142867437006615111, 1))

minusAMinusB = E.point((103762781993230069010083485164887172361256204634523864861966420595029658052179, -76878428888684998206116229633819067250185142636730603625369142867437006615111, 1))

aPlusBPlusAMinusB = aPlusB + aMinusB

# n: A scalar coefficient.
# Example: n = 7, which is the number of times that P is added to itself to compute the scalar multiple nP.
n = 2

# assume nP and n are defined
order = aPlusBPlusAMinusB.order()  # compute the order of the group generated by P
n_inv = inverse_mod(n, order)  # compute the inverse of n modulo the order of P
A = n_inv * aPlusBPlusAMinusB  # compute

print(f"{A = }")

aPlusBMinusAMinusB = aPlusB - aMinusB 

# assume nP and n are defined
order = aPlusBMinusAMinusB.order()  # compute the order of the group generated by P
n_inv = inverse_mod(n, order)  # compute the inverse of n modulo the order of P
B = n_inv * aPlusBMinusAMinusB  # compute
print(f"{B = }")


```
The result of the computation is :
```
A = (31780852818425402368588723596238022144324172071966766096317883677429500227940 : 74569787321104582225996912753355563908026849218458228201487958481976032452135 : 1)
B = (23621324903648026841506078943077513175226970476813184636881033351763458273661 : 3657659247253564334277014898432377210451558255976172146041222221013624703251 : 1)
```

Now that we have the coordinates of A and B, we can use the following Python code to reverse back to the flag.

Having :

Ax = K(bytes_to_long(flag[:mid]))

So bytes_to_long(flag[:mid]) = Ax + p * i

We will loop on i from 0 to 10 and see what we will get.

```python
from Crypto.Util.number import long_to_bytes

Ax = 31780852818425402368588723596238022144324172071966766096317883677429500227940  
#Ax = 46316835694926478169428394003475163141307993866256225615783033603165251855973       
Bx = 23621324903648026841506078943077513175226970476813184636881033351763458273661  


for i in range(0,10) :

    realFlagFirstLong = Ax + p * i
    realFlagSecondLong = Bx + p * i

    realFlagFirstBytes = long_to_bytes(realFlagFirstLong)
    realFlagSecondBytes = long_to_bytes(realFlagSecondLong)

    print("realFlagFirstBytes : ", realFlagFirstBytes)
    print("realFlagSecondBytes : ", realFlagSecondBytes)
```
The result of the execution is :
```
realFlagFirstBytes :  b'FCSC{a0c43dbbfaac7a84b5ce7feb81d'
realFlagSecondBytes :  b'492431a69a214d768aa4383aabfd241}'
realFlagFirstBytes :  b'\x01FCSB{a0d43dbbfaac7a94b5ce7feb81c'
realFlagSecondBytes :  b'\x01492331a79a214d768aa5383aabfd241|'
realFlagFirstBytes :  b'\x02FCSA{a0e43dbbfaac7a:4b5ce7feb81b'
realFlagSecondBytes :  b'\x02492231a89a214d768aa6383aabfd241{'
realFlagFirstBytes :  b'\x03FCS@{a0f43dbbfaac7a;4b5ce7feb81a'
realFlagSecondBytes :  b'\x03492131a99a214d768aa7383aabfd241z'
realFlagFirstBytes :  b'\x04FCS?{a0g43dbbfaac7a<4b5ce7feb81`'
realFlagSecondBytes :  b'\x04492031a:9a214d768aa8383aabfd241y'
realFlagFirstBytes :  b'\x05FCS>{a0h43dbbfaac7a=4b5ce7feb81_'
realFlagSecondBytes :  b'\x05492/31a;9a214d768aa9383aabfd241x'
realFlagFirstBytes :  b'\x06FCS={a0i43dbbfaac7a>4b5ce7feb81^'
realFlagSecondBytes :  b'\x06492.31a<9a214d768aa:383aabfd241w'
realFlagFirstBytes :  b'\x07FCS<{a0j43dbbfaac7a?4b5ce7feb81]'
realFlagSecondBytes :  b'\x07492-31a=9a214d768aa;383aabfd241v'
realFlagFirstBytes :  b'\x08FCS;{a0k43dbbfaac7a@4b5ce7feb81\\'
realFlagSecondBytes :  b'\x08492,31a>9a214d768aa<383aabfd241u'
realFlagFirstBytes :  b'\tFCS:{a0l43dbbfaac7aA4b5ce7feb81['
realFlagSecondBytes :  b'\t492+31a?9a214d768aa=383aabfd241t'
```

We can notice that we find the flag with i = 0 : FCSC{a0c43dbbfaac7a84b5ce7feb81d492431a69a214d768aa4383aabfd241}